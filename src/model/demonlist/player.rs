pub use self::{
    paginate::{PlayerPagination, RankingPagination},
    patch::PatchPlayer,
};
use crate::{
    cistring::CiString,
    model::{
        demonlist::{demon::MinimalDemon, record::MinimalRecordD},
        nationality::Nationality,
    },
    Result,
};
use derive_more::Display;
use serde::Serialize;
use sqlx::PgConnection;
use std::hash::{Hash, Hasher};

mod get;
mod paginate;
mod patch;

#[derive(Debug, Hash, Eq, PartialEq, Serialize, Display, Clone)]
#[display(fmt = "{} (ID: {})", name, id)]
pub struct DatabasePlayer {
    pub id: i32,
    pub name: CiString,
    pub banned: bool,
}

#[derive(Debug, Serialize, Display, PartialEq, Eq)]
#[display(fmt = "{}", player)]
pub struct FullPlayer {
    #[serde(flatten)]
    pub player: Player,
    pub records: Vec<MinimalRecordD>,
    pub created: Vec<MinimalDemon>,
    pub verified: Vec<MinimalDemon>,
    pub published: Vec<MinimalDemon>,
}

#[derive(Debug, PartialEq, Serialize, Display)]
#[display(fmt = "{} (ID: {}) at rank {} with score {}", name, id, rank, score)]
pub struct RankedPlayer {
    pub id: i32,
    pub name: CiString,
    pub rank: i64,
    pub score: f64,
    pub nationality: Option<Nationality>,
    #[serde(skip)]
    pub index: i64,
}

#[derive(Debug, Eq, Hash, PartialEq, Serialize, Display)]
#[display(fmt = "{}", base)]
pub struct Player {
    #[serde(flatten)]
    pub base: DatabasePlayer,

    pub nationality: Option<Nationality>,
}

impl Hash for FullPlayer {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.player.hash(state)
    }
}

impl RankedPlayer {
    /// Gets the highest index value generated by the `players_with_score` view
    pub async fn max_index(connection: &mut PgConnection) -> Result<i64> {
        Ok(sqlx::query!("SELECT MAX(index) AS max_index FROM players_with_score")
            .fetch_one(connection)
            .await?
            .max_index)
    }
}

impl Player {
    /// Gets the maximal and minimal player id currently in use
    ///
    /// The returned tuple is of the form (max, min)
    pub async fn extremal_player_ids(connection: &mut PgConnection) -> Result<(i32, i32)> {
        let row = sqlx::query!("SELECT MAX(id) AS max_id, MIN(id) AS min_id FROM players")
            .fetch_one(connection)
            .await?; // FIXME: crashes on empty table
        Ok((row.max_id, row.min_id))
    }
}
